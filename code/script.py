# -*- coding: utf-8 -*-
"""Dálkamyndun fyrir limtre.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IobHrhWBh4yZW2DKEFhNkpt5xLvDxhZ7
"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
!pip install gurobipy
import numpy as np
import urllib
import matplotlib.pyplot as plt
import pandas as pd
from gurobipy import *

gb_env = Env(empty=True)
gb_env.setParam('WLSACCESSID', 'str')
gb_env.setParam('WLSSECRET', 'str')
gb_env.setParam('LICENSEID', 0)
#gb_env.start()

sheet_id = "1vYhh4uTrDUk-sv0b1x12DZtBMDiMUfZjL0SCF_CX-bI"
data = pd.read_csv(f"https://docs.google.com/spreadsheets/d/{sheet_id}/gviz/tq?tqx=out:csv&sheet=Sheet1", index_col=0).dropna(how='all', axis='columns')
data['length'] = data['length'].str.replace(",","").astype('int')

f"https://docs.google.com/spreadsheets/d/{sheet_id}/gviz/tq?tqx=out:csv&sheet=Sheet1"

# Skoðum gögnin (athugið að "count" er fjöldi 45mm fjala (hæð)):
data_type = data.groupby(['width']).size() # tökum saman sömu breidd
uwidth = data_type.index.tolist()
data = data.loc[data['width']==uwidth[0]] # tökum aðeins eina breidd
pontun_nafn = data.index
data.index = list(range(0,len(data))) # númerum pantanir frá 0 til m-1
data

# Patterns (initial patterns is one order per pattern):
n = len(data)
rollwidth = 25000
widths = np.array(data['length'].tolist())
orders = np.array(data['number'].tolist())
height = np.array(data['height'].tolist())

m = len(data)
A = np.zeros((m,m))
for i in range(m):
  A[i,i] = np.floor(rollwidth / widths[i])

def dalkamyndun(pi, A, widths, height, rollwidth, debug = True):
  n = A.shape[1]
  I = list(range(A.shape[0]))
  bigM = 1000000
  knapmodel = Model("Knapsack")
  knapmodel.setParam('OutputFlag', 0)
  # Decision variables (the pattern to enter the basis)
  use = knapmodel.addVars(I, lb = 0, vtype = GRB.INTEGER)
  y = knapmodel.addVar()
  z = knapmodel.addVars(I, vtype = GRB.BINARY)
  reduced_cost = knapmodel.setObjective(1.0 - quicksum(pi[i] * use[i] for i in I), GRB.MINIMIZE)
  width_limit = knapmodel.addConstr(quicksum(widths[i]*use[i] for i in I) <= rollwidth)
  indicator_ = knapmodel.addConstrs(z[i]*bigM >= use[i] for i in I)
  height_limit_low = knapmodel.addConstrs(y >= height[i] - bigM*(1-z[i]) for i in I)
  height_limit_high = knapmodel.addConstrs(y <= height[i] + bigM*(1-z[i]) for i in I)
  knapmodel.optimize()
  if (knapmodel.objval < -0.0000001):
    if debug:
      print("knap=",knapmodel.objval)
    A = np.hstack((A,np.array([[use[i].X] for i in I])))
  else:
    return A, True
  return A, False

bailout = False
while bailout == False:
  I = range(m)
  J = range(A.shape[1])
  # Create the cutting model
  cutmodel = Model("Cutting")
  cutmodel.setParam('OutputFlag', 0)
  # Decision variables (how often should we cut pattern j in J)
  x = cutmodel.addVars(J)
  cutmodel.setObjective(quicksum(x[j] for j in J), GRB.MINIMIZE)
  cutmodel.addConstrs(quicksum(A[i,j]*x[j] for j in J) >= orders[i] for i in I)
  # solve the model
  cutmodel.optimize()
  # now let's get the dual solution
  pi = [c.Pi for c in cutmodel.getConstrs()]
  # now solve the column generation problem
  A, bailout = dalkamyndun(pi, A, widths, height, rollwidth)

cutmodel = Model("Cutting final model")
# Decision variable, how often should we cut each pattern
x = cutmodel.addVars(J, lb=0, vtype = GRB.CONTINUOUS, name="x") # try also vtype = GRB.INTEGER
number = cutmodel.setObjective(quicksum(x[j] for j in J), GRB.MINIMIZE)
constraint = cutmodel.addConstrs(quicksum(A[i,j]*x[j] for j in J) >= orders[i] for i in I)
# solve the model
cutmodel.optimize()

# Now extract the integer solution via flooring
xSolution = cutmodel.getAttr('x', x)
xfloor = np.floor(xSolution.values())
order_id = np.array(data.index.tolist())
print("Patterns used:")
ExcelTafla = []
pressa = 0
pressuhaed = 0
for j in J:
  if xfloor[j] > 0:
    for _ in range(int(xfloor[j])):
    #  print(xfloor[j].astype('int'), 'x', list(np.where(np.floor(A[:,j])>0))[0]," fjöldi ",A[np.where(np.floor(A[:,j])>0),j].astype(int).tolist()[0])
    #  print(len(A[:,j]),len(xfloor),len(widths))
      totlength = np.sum(A[:,j] * widths)
      haed = height[list(np.where(np.floor(A[:,j])>0))[0][0]] / 45
      if pressuhaed+haed > 28:
        pressuhaed = 0
        pressa = pressa + 1
      pressuhaed = pressuhaed + haed
      ExcelTafla.append(np.hstack((j,haed,totlength,pressa,pressuhaed,A[:,j].T)).tolist())
      #print("length =", totlength, "rest = ", rollwidth-totlength)
df = pd.DataFrame(np.array(ExcelTafla).astype('int'))
missingorder = (orders - A @ xfloor.transpose()).astype('int')
#print("missingorders = ", missingorder)
for i in range(len(missingorder)):
  if missingorder[i] > 0:
    print(missingorder[i], "/", orders[i], "missing from order", i)
print("each roll has length = ", rollwidth, " missing material in rollwidth:",  np.ceil(missingorder @ widths.transpose() / rollwidth))
print("the total number of rolls used is at least ", int(np.sum(xfloor))+np.ceil(missingorder @ widths.transpose() / rollwidth))
df.columns = ['MynsturID']+['haed','lengd','lota','pressuhaed']+pontun_nafn.tolist()
df.to_excel('lausn.xlsx', index=False)
df